<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bukankah ini My</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/png" href="picla/icon.png">
</head>
<body>
    <!-- Loading Page Animation -->
    <div id="loading-page" class="loading-page">
        <div class="loader-container">
            <div class="loader">
                <div class="loader-dot"></div>
                <div class="loader-dot"></div>
                <div class="loader-dot"></div>
            </div>
            <p class="loading-text">Loading...</p>
        </div>
    </div>

    <!-- Click Me Page -->
    <div id="click-me-page" class="click-me-page">
        <div class="click-me-container">
            <h1 class="click-me-title">WELCOME TYRANT</h1>
            <button class="click-me-button" onclick="hideClickMePage()">LOGIN</button>
        </div>
    </div>

    <!-- Hexagon Animation Container - Full Screen Grid -->
    <canvas id="hexagon-canvas" class="hexagon-canvas"></canvas>

    <div class="main-wrapper">
        <!-- Left Sidebar Tray -->
        <div class="sidebar-tray">
            <div class="sidebar-header">
                <h2>Directories</h2>
            </div>
            <div class="sidebar-list" id="sidebar-list">
                <div class="empty-list">Loading...</div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content-wrapper">
            <div class="container">
                <div class="header">
                    <h1 style="color: black; font-family: 'NEXON Football Gothic L', sans-serif;">Foto my</h1>
                </div>

                <div class="gallery-wrapper">
                    <div id="items-container" style="position: relative;">
                        <!-- Directory Loading Hexagon Canvas -->
                        <canvas id="directory-hexagon-canvas" class="directory-hexagon-canvas"></canvas>
                        
                        <div id="empty-state" class="empty-state">
                            <p>Loading gallery...</p>
                        </div>
                    </div>

                    <!-- Preview Panel -->
                    <div class="preview-panel" id="preview-panel">
                        <div class="preview-content">
                            <div class="preview-placeholder">
                                <p>Preview of My</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Zoom Modal -->
    <div id="zoom-modal" class="zoom-modal">
        <div class="zoom-container">
            <img id="zoom-image" class="zoom-image" src="" alt="">
            <video id="zoom-video" class="zoom-image" controls style="display: none;"></video>
            <button class="zoom-close" onclick="closeZoom()">&times;</button>
        </div>
    </div>

    <!-- Audio Player for BGM -->
    <audio id="bgm-audio" loop style="display: none;"></audio>

    <!-- BGM Player - Bottom Right Corner -->
    <div id="bgm-player" style="position: fixed; bottom: 20px; right: 20px; z-index: 1000; background: linear-gradient(135deg, rgba(11,26,36,0.95), rgba(3,4,10,0.95)); padding: 14px; border-radius: 2px; box-shadow: 0 0 30px rgba(78,192,255,0.4), inset 0 1px 0 rgba(255,255,255,0.05); border: 2px solid rgba(78,192,255,0.5); display: none; flex-direction: column; gap: 10px; align-items: stretch; max-width: 320px; backdrop-filter: blur(8px);">
        <!-- Progress Bar -->
        <div style="width: 100%; height: 6px; background: rgba(0,0,0,0.5); border: 1px solid rgba(78,192,255,0.3); border-radius: 2px; overflow: hidden; box-shadow: inset 0 0 8px rgba(78,192,255,0.2);">
            <div id="bgm-progress" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4ec0ff, #7be0c8); transition: width 0.1s linear; box-shadow: 0 0 8px rgba(78,192,255,0.6);"></div>
        </div>
        <!-- Time Display -->
        <div style="font-size: 9px; color: rgba(212,228,239,0.7); font-family: 'Courier New', monospace; text-align: center;">
            <span id="bgm-time-current">0:00</span> / <span id="bgm-time-duration">0:00</span>
        </div>
        <!-- Controls -->
        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
            <label style="color: #4ec0ff; font-size: 10px; font-weight: 700; letter-spacing: 1.5px; text-transform: uppercase; text-shadow: 0 0 8px rgba(78,192,255,0.6);">üéµ BGM</label>
            <select id="bgm-select" style="padding: 6px 8px; border-radius: 2px; border: 1px solid rgba(78,192,255,0.6); background: rgba(3,4,10,0.8); cursor: pointer; font-size: 11px; color: #d7eef9; font-family: 'Courier New', monospace; box-shadow: 0 0 12px rgba(78,192,255,0.2); flex: 1; min-width: 100px;">
                <option value="">-- None --</option>
            </select>
            <button id="bgm-toggle" style="padding: 6px 12px; border-radius: 2px; border: 1px solid rgba(78,192,255,0.6); background: linear-gradient(135deg, rgba(78,192,255,0.2), rgba(78,192,255,0.1)); cursor: pointer; font-size: 10px; font-weight: 600; color: #4ec0ff; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; box-shadow: 0 0 10px rgba(78,192,255,0.3);">‚ñ∂ Play</button>
            <input id="bgm-volume" type="range" min="0" max="100" value="5" style="width: 60px; cursor: pointer; height: 6px; accent-color: #4ec0ff; border-radius: 3px;">
        </div>
    </div>

    <script>
        let items = [];
        let currentFolder = 'laimage';
        let folders = ['laimage'];
        const SUPPORTED_FORMATS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'mp4', 'webm'];

        // Initialize on load: try to read folders.json (optional), then load the default folder
        (async function init() {
            await loadFolders();
            await loadItems(currentFolder);
        })();

        // Try to fetch a folders.json which can list available directories.
        // The file can be an array of strings (paths) or array of objects { path, label }.
        async function loadFolders() {
            try {
                const res = await fetch('folders.json');
                if (!res.ok) throw new Error('no folders.json');
                const data = await res.json();
                if (Array.isArray(data)) {
                    folders = data.map(f => typeof f === 'string' ? { path: f, label: f } : { path: f.path, label: f.label || f.path, icon: f.icon });
                }
            } catch (e) {
                // fallback to default
                folders = [{ path: 'laimage', label: 'laimage' }];
            }
            renderFolderList();
        }

        function renderFolderList() {
            const sidebar = document.getElementById('sidebar-list');
            sidebar.innerHTML = folders.map((f, idx) => {
                const thumbContent = f.icon ? 
                    `<img src="${f.icon}" alt="${f.label}" style="width: 100%; height: 100%; object-fit: cover;">` :
                    `<div class="no-thumb">üìÅ</div>`;
                return `
                    <div class="sidebar-item" data-path="${f.path}" onclick="onDirectoryClick(this, '${f.path}')">
                        <div class="sidebar-item-thumb">${thumbContent}</div>
                        <div class="sidebar-item-text">
                            <div class="sidebar-item-title">${escapeHtml(f.label)}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function onDirectoryClick(element, path) {
            // Add animation class
            element.classList.add('clicked');
            
            // Remove animation class after animation completes
            setTimeout(() => {
                element.classList.remove('clicked');
            }, 600);
            
            // Load items
            loadItems(path).then(() => {
                // Show hexagon animation after 1 second delay
                setTimeout(() => {
                    directoryHexGrid.start();
                }, 1000);
                
                // Hide hexagon animation after 1.3 seconds of animation (total 2.3 seconds)
                setTimeout(() => {
                    const canvas = document.getElementById('directory-hexagon-canvas');
                    canvas.style.display = 'none';
                }, 2300);
            });
        }

        async function loadItems(folderPath) {
            currentFolder = folderPath;
            const container = document.getElementById('items-container');
            container.innerHTML = '<div class="empty-state"><p>Loading gallery...</p></div>';
            try {
                const response = await fetch(`${folderPath}/manifest.json`);
                if (response.ok) {
                    items = await response.json();
                } else {
                    items = [];
                }
            } catch (error) {
                console.error('Error loading manifest for', folderPath, error);
                items = [];
            }
            displayItems();
        }

        function imageUrl(name) {
            return `${currentFolder}/${name}`;
        }

        function displayItems() {
            const container = document.getElementById('items-container');
            if (!items || items.length === 0) {
                container.innerHTML = `<div id="empty-state" class="empty-state"><p>No images in ${escapeHtml(currentFolder)}. Add images and a manifest.json to the folder.</p></div>`;
                return;
            }

            const itemsHTML = items.map((item, index) => {
                const mediaElement = item.image ?
                    `<img src="${imageUrl(item.image)}" alt="${item.name}" class="item-image">` :
                    '<div class="no-image">No Media</div>';

                return `
                    <div class="item-card" onclick="showPreview(${index})">
                        ${mediaElement}
                        <div class="item-content">
                            <h3>${escapeHtml(item.name)}</h3>
                            ${item.description ? `<p class="note">${escapeHtml(item.description)}</p>` : ''}
                            ${item.date ? `<p class="timestamp">${item.date}</p>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = itemsHTML;
        }

        function showPreview(index) {
            if (index < 0 || index >= items.length) return;
            const item = items[index];
            const previewPanel = document.getElementById('preview-panel');

            if (!item.image) {
                previewPanel.innerHTML = '<div class="preview-content"><div class="preview-placeholder"><p>No media available</p></div></div>';
                return;
            }

            const isVideo = /\.(mp4|webm|avi|mov|mkv)$/i.test(item.image);
            let mediaHTML = '';
            if (isVideo) {
                mediaHTML = `<video class="preview-video-player" controls onclick="openZoom('${item.image}', true)" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px; cursor: zoom-in;"><source src="${imageUrl(item.image)}"></video>`;
            } else {
                mediaHTML = `<img src="${imageUrl(item.image)}" alt="${item.name}" onclick="openZoom('${item.image}', false)" style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px; cursor: zoom-in;">`;
            }

            previewPanel.innerHTML = `
                <div class="preview-content">
                    <div class="preview-media">
                        ${mediaHTML}
                    </div>
                    <div class="preview-info">
                        <h2>${escapeHtml(item.name)}</h2>
                        ${item.description ? `<p>${escapeHtml(item.description)}</p>` : ''}
                        ${item.date ? `<p class="preview-date">üìÖ ${item.date}</p>` : ''}
                    </div>
                </div>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function openZoom(imagePath, isVideo = false) {
            const modal = document.getElementById('zoom-modal');
            const zoomImg = document.getElementById('zoom-image');
            const zoomVid = document.getElementById('zoom-video');

            if (isVideo) {
                zoomImg.style.display = 'none';
                zoomVid.style.display = 'block';
                zoomVid.src = imageUrl(imagePath);
            } else {
                zoomVid.style.display = 'none';
                zoomImg.style.display = 'block';
                zoomImg.src = imageUrl(imagePath);
            }

            modal.classList.add('active');
        }

        function closeZoom() {
            const modal = document.getElementById('zoom-modal');
            modal.classList.remove('active');
            document.getElementById('zoom-image').src = '';
            document.getElementById('zoom-video').src = '';
        }

        // Close zoom modal on background click
        document.getElementById('zoom-modal').addEventListener('click', function(e) {
            if (e.target === this) closeZoom();
        });

        // Close zoom modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') closeZoom();
        });

        // ===== BGM Player Logic =====
        let bgmList = [];
        let bgmAudio = document.getElementById('bgm-audio');
        const bgmSelect = document.getElementById('bgm-select');
        const bgmToggle = document.getElementById('bgm-toggle');
        const bgmVolume = document.getElementById('bgm-volume');

        // Load BGM list from manifest
        async function loadBGM() {
            try {
                const res = await fetch('labgm/manifest.json');
                if (res.ok) {
                    bgmList = await res.json();
                    renderBGMSelect();
                    // Just set the first BGM src, don't play it yet
                    if (bgmList.length > 0) {
                        bgmSelect.value = '0';
                        const bgm = bgmList[0];
                        if (bgm && bgm.image) {
                            bgmAudio.src = 'labgm/' + bgm.image;
                            bgmAudio.volume = 0.03;  // Set initial volume to 0.05 (5%)
                        }
                    }
                }
            } catch (e) {
                console.error('Error loading BGM manifest:', e);
            }
        }

        function renderBGMSelect() {
            bgmSelect.innerHTML = bgmList.map((item, idx) => 
                `<option value="${idx}">${escapeHtml(item.name)}</option>`
            ).join('');
        }

        function playBGM(idx) {
            const bgm = bgmList[idx];
            if (bgm && bgm.image) {
                bgmAudio.src = 'labgm/' + bgm.image;
                bgmAudio.volume = 0.05;  // Set volume to 50%
                bgmAudio.muted = false;  // Unmute when playing
                bgmAudio.play();
                bgmToggle.textContent = 'Pause';
                document.getElementById('bgm-player').style.display = 'flex';  // Show player
            }
        }

        // Handle BGM selection
        bgmSelect.addEventListener('change', function() {
            if (this.value === '') {
                bgmAudio.pause();
                bgmAudio.src = '';
                bgmToggle.textContent = 'Play';
                document.getElementById('bgm-player').style.display = 'none';  // Hide player
                return;
            }
            const idx = parseInt(this.value);
            playBGM(idx);
        });

        // Handle play/pause toggle
        bgmToggle.addEventListener('click', function() {
            if (bgmAudio.src === '') return;
            if (bgmAudio.paused) {
                bgmAudio.play();
                this.textContent = 'Pause';
            } else {
                bgmAudio.pause();
                this.textContent = 'Play';
            }
        });

        // Handle volume control
        bgmVolume.addEventListener('input', function() {
            bgmAudio.volume = this.value / 100;
            bgmAudio.muted = false;  // Unmute when user adjusts volume
        });

        // Format time helper
        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update progress bar and time display
        bgmAudio.addEventListener('timeupdate', function() {
            const progress = (this.currentTime / this.duration) * 100;
            document.getElementById('bgm-progress').style.width = progress + '%';
            document.getElementById('bgm-time-current').textContent = formatTime(this.currentTime);
        });

        // Update duration when metadata loads
        bgmAudio.addEventListener('loadedmetadata', function() {
            document.getElementById('bgm-time-duration').textContent = formatTime(this.duration);
        });

        // Update play button text when audio ends
        bgmAudio.addEventListener('ended', function() {
            bgmToggle.textContent = '‚ñ∂ Play';
        });

        // Initialize BGM on page load
        loadBGM();

        // Hexagon Grid Animation
        class HexagonGrid {
            constructor() {
                this.canvas = document.getElementById('hexagon-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.hexagons = [];
                this.animationProgress = 0;
                this.isAnimating = false;
                
                this.setupCanvas();
                this.createHexagonGrid();
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.canvas.style.display = 'none';
            }

            createHexagonGrid() {
                const hexSize = 60;
                const hexWidth = hexSize * Math.sqrt(3);
                const hexHeight = hexSize * 2;
                const vertSpacing = hexHeight * 0.75;
                
                for (let row = -1; row * vertSpacing < this.canvas.height + hexHeight * 2; row++) {
                    for (let col = -1; col * hexWidth < this.canvas.width + hexWidth * 2; col++) {
                        let x = col * hexWidth;
                        let y = row * vertSpacing;
                        
                        // Offset every other row for proper hexagon packing
                        if (row % 2 === 1) {
                            x += hexWidth / 2;
                        }
                        
                        // Calculate delay based on x position (left to right)
                        const xRatio = x / this.canvas.width;
                        const delay = xRatio * 0.8; // Spreads animation across 0.8 seconds
                        
                        this.hexagons.push({
                            x: x,
                            y: y,
                            size: hexSize,
                            opacity: 1,
                            delay: delay
                        });
                    }
                }
            }

            drawHexagon(x, y, size, opacity) {
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = '#031027';
                this.ctx.strokeStyle = '#0b1a24';
                this.ctx.lineWidth = 2;
                
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 30) * Math.PI / 180;
                    const px = x + size * Math.cos(angle);
                    const py = y + size * Math.sin(angle);
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.restore();
            }

            animate(progress) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.hexagons.forEach(hex => {
                    const delayedProgress = Math.max(0, progress - hex.delay);
                    const hexProgress = Math.min(1, delayedProgress / 0.5); // Smoother fade duration
                    hex.opacity = 1 - hexProgress;
                    this.drawHexagon(hex.x, hex.y, hex.size, hex.opacity);
                });

                if (progress < 1.3) {
                    requestAnimationFrame(() => this.animate(progress + 0.016));
                } else {
                    this.canvas.style.display = 'none';
                }
            }

            start() {
                this.canvas.style.display = 'block';
                this.animate(0);
            }
        }

        // Directory Hexagon Grid Animation (for items container only)
        class DirectoryHexagonGrid {
            constructor() {
                this.canvas = document.getElementById('directory-hexagon-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.hexagons = [];
                this.animationProgress = 0;
                this.isAnimating = false;
                
                this.setupCanvas();
                this.createHexagonGrid();
            }

            setupCanvas() {
                const container = document.getElementById('items-container');
                this.canvas.width = container.offsetWidth;
                this.canvas.height = container.offsetHeight;
                this.canvas.style.display = 'none';
            }

            createHexagonGrid() {
                const hexSize = 40;
                const hexWidth = hexSize * Math.sqrt(3);
                const hexHeight = hexSize * 2;
                const vertSpacing = hexHeight * 0.75;
                
                for (let row = -1; row * vertSpacing < this.canvas.height + hexHeight * 2; row++) {
                    for (let col = -1; col * hexWidth < this.canvas.width + hexWidth * 2; col++) {
                        let x = col * hexWidth;
                        let y = row * vertSpacing;
                        
                        // Offset every other row for proper hexagon packing
                        if (row % 2 === 1) {
                            x += hexWidth / 2;
                        }
                        
                        // Calculate delay based on x position (left to right)
                        const xRatio = x / this.canvas.width;
                        const delay = xRatio * 0.8;
                        
                        this.hexagons.push({
                            x: x,
                            y: y,
                            size: hexSize,
                            opacity: 1,
                            delay: delay
                        });
                    }
                }
            }

            drawHexagon(x, y, size, opacity) {
                this.ctx.save();
                this.ctx.globalAlpha = opacity;
                this.ctx.fillStyle = '#031027';
                this.ctx.strokeStyle = '#0b1a24';
                this.ctx.lineWidth = 1.5;
                
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * 60 - 30) * Math.PI / 180;
                    const px = x + size * Math.cos(angle);
                    const py = y + size * Math.sin(angle);
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                this.ctx.restore();
            }

            animate(progress) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const FADE_IN_END = 0.65;
                const TOTAL_DURATION = 1.3;
                
                this.hexagons.forEach(hex => {
                    const delayedProgress = Math.max(0, progress - hex.delay);
                    
                    let opacity;
                    if (delayedProgress < FADE_IN_END) {
                        // Fade in phase (0 to 0.65s)
                        const fadeInProgress = Math.min(1, delayedProgress / 0.5);
                        opacity = fadeInProgress;
                    } else {
                        // Fade out phase (0.65s to 1.3s)
                        const fadeOutProgress = Math.min(1, (delayedProgress - FADE_IN_END) / 0.5);
                        opacity = 1 - fadeOutProgress;
                    }
                    
                    this.drawHexagon(hex.x, hex.y, hex.size, opacity);
                });

                if (progress < TOTAL_DURATION) {
                    requestAnimationFrame(() => this.animate(progress + 0.016));
                }
            }

            start() {
                this.canvas.style.display = 'block';
                this.hexagons = [];
                this.createHexagonGrid();
                this.animate(0);
            }
        }

        const hexGrid = new HexagonGrid();
        const directoryHexGrid = new DirectoryHexagonGrid();
        
        window.addEventListener('resize', () => {
            hexGrid.setupCanvas();
            hexGrid.hexagons = [];
            hexGrid.createHexagonGrid();
            
            directoryHexGrid.setupCanvas();
            directoryHexGrid.hexagons = [];
            directoryHexGrid.createHexagonGrid();
        });

        // Play BGM when user clicks LOGIN button
        function hideClickMePage() {
            // Start hexagon grid animation
            hexGrid.start();

            // Play BGM on LOGIN button click
            if (bgmList.length > 0 && bgmAudio.src && bgmAudio.paused) {
                bgmAudio.muted = false;
                bgmAudio.play().catch(err => console.log('Autoplay blocked:', err));
                bgmToggle.textContent = '‚è∏ Pause';
                document.getElementById('bgm-player').style.display = 'flex';  // Show player
            }

            // Hide click me page and show main content
            const clickMePage = document.getElementById('click-me-page');
            clickMePage.classList.add('fade-out');
            setTimeout(function() {
                clickMePage.style.display = 'none';
                hexagonContainer.classList.remove('show-hexagons');
            }, 500);
        }

        // Hide loading screen when page is fully loaded
        window.addEventListener('load', function() {
            const loadingPage = document.getElementById('loading-page');
            loadingPage.classList.add('fade-out');
            setTimeout(function() {
                loadingPage.style.display = 'none';
                // Show click me page after loading finishes
                document.getElementById('click-me-page').style.display = 'flex';
            }, 500);
        });
    </script>
    <!-- hai sayang -->
</body>
</html>

